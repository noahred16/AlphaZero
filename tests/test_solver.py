import pytest
from games.connect4 import Connect4
from util.solver import Solver
from util.mcts import MCTS
import numpy as np


def test_solver_evaluate_state():
    game = Connect4(num_of_rows=4, num_of_cols=4)
    solver = Solver(game)

    # X = 1, O = -1
    # [ _ | _ | _ | _ ]
    # [ X | 0 | _ | _ ]
    # [ X | O | _ | _ ]
    # [ X | O | _ | _ ]
    #   0   1   2   3

    # value: 1 (X wins next move)
    # policy: [0.68, 0.32, 0, 0]

    game.make_move(0)
    game.make_move(1)
    game.make_move(0)
    game.make_move(1)
    game.make_move(0)
    game.make_move(1)

    game.print_pretty()

    policy_label, value_label = solver.evaluate_state()

    assert value_label == 1  # scaled between best and worst score
    assert round(policy_label[0], 2) == 0.68  # best move
    assert round(policy_label[1], 2) == 0.32  # okay move, leads to tie
    assert round(policy_label[2], 2) == 0.0  # bad move, leads to loss
    assert round(policy_label[3], 2) == 0.0  # bad move, leads to loss
    assert round(sum(policy_label), 2) == 1.0  # assert probabilities sum to 1


def test_solver_empty_board():
    game = Connect4(num_of_rows=4, num_of_cols=4)
    solver = Solver(game)

    # evaluation for empty board
    policy_label, value_label = solver.evaluate_state()

    assert value_label == 0  # all moves lead to a tie given optimally play
    # assert all moves are 0.25 rounded
    for i in range(4):
        assert round(policy_label[i], 2) == 0.25


def test_mcts_move_probabilities():
    game = Connect4(num_of_rows=4, num_of_cols=4)
    mcts = MCTS(iterations=100)
    move_probs = mcts.search(game)
    
    # this just checks if the move probs generated by mcts sum to 1
    assert np.isclose(np.sum(move_probs), 1.0)
    
    # additionally check that illegal moves have zero probability
    legal_moves = game.get_legal_moves()
    for move in range(game.num_of_cols):
        if move not in legal_moves:
            assert move_probs[move] == 0.0


def test_mcts_samples_collection():
    """
    test made to ensure the mcts code is actually recording the board states and the outcomes obtained from its simulations. 
    this ensures we have well formed training data to feed into NN later.
    """
    game = Connect4(num_of_rows=4, num_of_cols=4)
    mcts = MCTS(iterations=50)
    mcts.search(game)
    samples = mcts.get_samples()
    
    # basic check
    assert len(samples) > 0
    
    # check that each sample has the correct board shape and reward value
    for board_state, reward in samples:
        assert board_state.shape == (game.num_of_rows, game.num_of_cols)
        # reward should be one of -1, 0, or 1
        assert reward in [-1, 0, 1]